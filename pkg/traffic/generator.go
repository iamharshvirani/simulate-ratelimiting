package traffic

import (
	"math/rand"
	"time"
)

// Event represents a single camera event generated for a given second.
// A higher-level simulator can convert this into its own request message type.
// Timestamp is filled at generation time so workers can optionally measure end-to-end latency.
// RateLimited tells the simulator whether to apply the rate-limiter before
// submitting the event to a GPU pod.

type Event struct {
	CameraID    string
	Timestamp   time.Time
	RateLimited bool
}

// GenerateEventsSecond returns a slice of Event objects representing all camera
// events that should occur during wall-clock second `t` of the simulation
// (0-based). Generation obeys the rules encoded in cfg and the provided group
// definitions.
//
// Algorithm:
//  1. Compute the global multiplier for second t (sine 0.5×-2× or 1).
//  2. For every group, derive current per-camera rate = BaseRate × multiplier.
//  3. For each camera in the group, sample the number of events occurring in
//     this second using a light-weight Poisson approximation (integer part +
//     Bernoulli(fractional part)).
//  4. Append that many Event objects to the result slice.
//  5. Shuffle the slice so events arrive in random order rather than grouped
//     by camera.
func GenerateEventsSecond(t int, cfg CameraTrafficConfig, groups []CameraGroup) []Event {
	factor := Multiplier(t, cfg)
	// Rough upfront capacity guess helps to minimise reallocations: each camera
	// can generate up to 2×MaxRate events at peak.
	roughCap := int(float64(cfg.TotalCameras) * cfg.MaxRate * 2)
	events := make([]Event, 0, roughCap)

	now := time.Now()
	for _, g := range groups {
		curRate := g.BaseRate * factor
		if curRate <= 0 {
			continue
		}
		for _, camID := range g.CameraIDs {
			n := sampleEvents(curRate)
			for i := 0; i < n; i++ {
				events = append(events, Event{
					CameraID:    camID,
					Timestamp:   now,
					RateLimited: g.RateLimited,
				})
			}
		}
	}

	// Randomise order to avoid bursts per camera/group.
	rand.Shuffle(len(events), func(i, j int) { events[i], events[j] = events[j], events[i] })
	return events
}

// sampleEvents returns the number of events generated by a single camera in one
// second for a target mean rate. We use the following inexpensive approximation
// to a Poisson(λ) draw:
//
//	k = ⌊λ⌋
//	if rand.Float64() < (λ-k) then k++
//
// This has the correct mean and is sufficient for simulation purposes while
// avoiding the overhead of calling a full Poisson RNG for every camera.
func sampleEvents(rate float64) int {
	if rate <= 0 {
		return 0
	}
	k := int(rate)
	if rand.Float64() < rate-float64(k) {
		k++
	}
	return k
}
